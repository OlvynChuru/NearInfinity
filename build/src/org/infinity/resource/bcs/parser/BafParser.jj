/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. BafParser.jj */
/*@egen*/// Near Infinity - An Infinity Engine Browser and Editor
// Copyright (C) 2001 - 2005 Jon Olav Hauglid
// See LICENSE.txt for license information

/**
 * A BAF grammar for Infinity Engine game scripts that closely resembles the 
 * grammar used by the WeiDU compiler.
 */

/*
 * List of node names and their potential meanings:
 * - SC:        Start of script (for type=script)
 * - SEQ_TR:    Start of trigger sequence (for type=trigger)
 * - SEQ_AC:    Start of action sequence (for type=action)
 * - CR:        Condition-Response block
 * - CO:        Condition block
 * - RS:        Response-Set block
 * - RE:        Response block
 * - TR:        A trigger or object target structure
 * - AC:        An action or object target structure
 * - PARAM:     A function parameter follows
 * - PARAM_STR: A string or object parameter (script name) follows
 * - PARAM_NUM: A numeric or symbolic value follows - may consist of several elements (see below)
 * - PARAM_SYM: A potential unnested object target parameter follows
 * - PARAM_TGT: A target specifier or point parameter follows
 * - NAME:      Potential function name, symbolic name or object target name
 * - NUMERIC:   A numeric or symbolic value
 * - OR_EXPR:   Follows a PARAM_NUM node if the numeric value has to be computed from one or more OR expressions
 * - STRING:    A string in double quotes
 * - TARGET:    The actual target specifier (e.g. [PC.HUMANOID.0]) or point structure
 * - OBJECT:    A potential target object or function parameter definition
 * - SYMBOL:    A symbolic value or single target object
 * - RECT:      A rectangle definition
 * - UINT:      An unsigned number of any supported notation
 * - SINT:      A signed number of any supported notation
 * - SIGN:      The sign of a numeric value
 * - NEG:       Negation operator that may precede trigger definitions
 */

options {
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  JAVA_UNICODE_ESCAPE = true;
                      
                                                    
                         
  STATIC = false;
}

PARSER_BEGIN(BafParser)

// Near Infinity - An Infinity Engine Browser and Editor
// Copyright (C) 2001 - 2005 Jon Olav Hauglid
// See LICENSE.txt for license information

package org.infinity.resource.bcs.parser;

import org.infinity.resource.bcs.ScriptType;

public class BafParser/*@bgen(jjtree)*/implements BafParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected JJTBafParserState jjtree = new JJTBafParserState();

/*@egen*/
  private ScriptType scriptType;

  public BafParser(ScriptType type, java.io.InputStream stream)
  {
    this(stream);
    this.scriptType = type;
  }

  public BafParser(ScriptType type, java.io.InputStream stream, String encoding)
  {
    this(stream, encoding);
    this.scriptType = type;
  }

  public BafParser(ScriptType type, java.io.Reader stream)
  {
    this(stream);
    this.scriptType = type;
  }

  public BafParser(ScriptType type, BafParserTokenManager tm)
  {
    this(tm);
    this.scriptType = type;
  }

  /** 
   * Returns the script type of the input data.
   * Supported {@link ScriptType} values: {@link ScriptType#BAF}, {@link ScriptType#TRIGGER} and 
   *                                      {@link ScriptType#ACTION}.
   */
  public ScriptType getType()
  {
    return scriptType;
  }

  /**
   * Defines type of input data.
   * Supported {@link ScriptType} values: {@link ScriptType#BAF}, {@link ScriptType#TRIGGER} and 
   *                                      {@link ScriptType#ACTION}.
   */
  public void setType(ScriptType type)
  {
    this.scriptType = type;
  }

  /**
   * Returns the root node of the current script.
   * @return Root node of the current script.
   * @throws ParseException if current script type is unsupported or invalid.
   */
  public BafNode getRoot() throws ParseException
  {
    switch (scriptType) {
      case BAF:     return Script();
      case TRIGGER: return TriggerList();
      case ACTION:  return ActionList();
      default: throw new ParseException("Unsupported script type: " + scriptType.toString());
    }
  }

  /**
   * Returns the node name indicated by the specified index constant. Use one of the JJTxxx 
   * integer constants from {@link BafParserTreeConstants} for best results.
   * <b>Note:</b> See {@code BafParser.jjt} for more details.
   * @param jjtIndex Node index as defined in {@code BafParserTreeConstants}. 
   * @return node name, or {@code null} if undefined.
   */
  public static String getNodeName(int jjtIndex)
  {
    if (jjtIndex >= 0 && jjtIndex < jjtNodeName.length) {
      return jjtNodeName[jjtIndex];
    }
    return null;
  }
}

PARSER_END(BafParser)


/* WHITE SPACE */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */

// This expression works correctly even if comment is closed by <EOF>
SPECIAL_TOKEN :
{
  < SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")? >
}

MORE :
{
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  < MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* RESERVED KEYWORDS */
TOKEN :
{
  < IF: "IF" >
| < THEN: "THEN" >
| < RESPONSE: "RESPONSE" >
| < END: "END" >
}

/* LITERALS */

TOKEN :
{
  < NUMBER_LITERAL: <DEC_LITERAL> | <HEX_LITERAL> | <BIN_LITERAL> >
| < #DEC_LITERAL: (["0"-"9"])+ >
| < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
| < #BIN_LITERAL: "0" ["b","B"] (["0","1"])+ >
| < STRING_LITERAL: <STRING_QUOTE> | <STRING_PERCENT> | <STRING_POUND> | <STRING_MULTI_TILDE> | <STRING_TILDE> >
| < #STRING_QUOTE: "\"" (~["\"","\n","\r"])* "\"" >
| < #STRING_PERCENT: "%" (~["%","\n","\r"])* "%" >
| < #STRING_POUND: "#" (~["#","\n","\r"])* "#" >
| < #STRING_TILDE: "~" (~["~","\n","\r"])* "~" >
| < #STRING_MULTI_TILDE: "~~~~~" (~["\n","\r"])* "~~~~~" >
}

/* IDENTIFIERS */
TOKEN :
{
  < IDENTIFIER: <LETTER> ( <LETTER> | <SPECIAL_LETTER> | <DIGIT> )* >
// Special expression to display IDS symbols with characters not normally 
// allowed in identifiers
| < IDENTIFIER_ESCAPED:
    "\"" "\"" "\"" "\"" "\"" 
    ( ~["\"","\n","\r"] )*
    "\"" "\"" "\"" "\"" "\"" 
  >
| < #LETTER:
    [
      "A"-"Z",  // A .. Z
      "_",           // _
      "a"-"z",  // a .. z
      "\u00c0"-"\u00d6",  // \u00c3\u20ac .. \u00c3\u2013
      "\u00d8"-"\u00f6",  // \u00c3\u02dc .. \u00c3\u00b6
      "\u00f8"-"\u00ff"   // \u00c3\u00b8 .. \u00c3\u00bf
    ]
  >
| < #SPECIAL_LETTER:
    [
      "!",   // !
      "#",   // #
      "-"    // -
    ]
  >
| < #DIGIT:
    [
      "0"-"9"   // 0 .. 9
    ]
  >
}

/* SEPARATORS */
TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < COMMA: "," >
| < DOT: "." >
}

/* OPERATORS */
TOKEN :
{
  < BANG: "!" >
| < OR: "|" >
| < MINUS: "-" >
| < PLUS: "+" >
| < POUND: "#" >
}


/**************************************
 * THE BAF SCRIPT GRAMMAR STARTS HERE *
 **************************************/

/** Root node for processing a full BAF script source. */
BafNode Script()     : {/*@bgen(jjtree) SC */
  BafNode jjtn000 = new BafNode(JJTSC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) SC */
  try {
/*@egen*/
  ( ConditionResponse() )* <EOF>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

/** Root node for processing a sequence of script triggers. */
BafNode TriggerList()         : {/*@bgen(jjtree) SEQ_TR */
  BafNode jjtn000 = new BafNode(JJTSEQ_TR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) SEQ_TR */
  try {
/*@egen*/
  ( Trigger() )* <EOF>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

/** Root node for processing a sequence of script actions. */
BafNode ActionList()         : {/*@bgen(jjtree) SEQ_AC */
  BafNode jjtn000 = new BafNode(JJTSEQ_AC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) SEQ_AC */
  try {
/*@egen*/
  ( Action() )* <EOF>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetLastToken(getToken(0));
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}


void ConditionResponse()     : {/*@bgen(jjtree) CR */
  BafNode jjtn000 = new BafNode(JJTCR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) CR */
  try {
/*@egen*/
  Condition() ResponseSet() <END>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void Condition()     : {/*@bgen(jjtree) CO */
  BafNode jjtn000 = new BafNode(JJTCO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) CO */
  try {
/*@egen*/
  <IF> ( Trigger() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void ResponseSet()     : {/*@bgen(jjtree) RS */
  BafNode jjtn000 = new BafNode(JJTRS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) RS */
  try {
/*@egen*/
  <THEN> ( Response() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void Response()     : {/*@bgen(jjtree) RE */
  BafNode jjtn000 = new BafNode(JJTRE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) RE */
  try {
/*@egen*/
  <RESPONSE> <POUND> UnsignedNumber() ( Action() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void Trigger()       : {}
{
  LOOKAHEAD( TriggerOverride() ) TriggerOverride()
| TriggerGeneric()
}

void TriggerOverride()     : {/*@bgen(jjtree) TR */
  BafNode jjtn000 = new BafNode(JJTTR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) TR */
  try {
/*@egen*/
  ( Negate() )? Name() <LPAREN> ObjectParameter() <COMMA> TriggerParam() <RPAREN>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void TriggerParam()        : {/*@bgen(jjtree) PARAM */
  BafNode jjtn000 = new BafNode(JJTPARAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) PARAM */
  try {
/*@egen*/
  TriggerGeneric()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void TriggerGeneric()     : {/*@bgen(jjtree) TR */
  BafNode jjtn000 = new BafNode(JJTTR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) TR */
  try {
/*@egen*/
  ( Negate() )? Name() <LPAREN> ( ParameterList() )? <RPAREN>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void Action()       : {}
{
  LOOKAHEAD( ActionOverride() ) ActionOverride()
| ActionGeneric()
}

void ActionOverride()     : {/*@bgen(jjtree) AC */
  BafNode jjtn000 = new BafNode(JJTAC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) AC */
  try {
/*@egen*/
  Name() <LPAREN> ObjectParameter() <COMMA> ActionParam() <RPAREN>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void ActionParam()        : {/*@bgen(jjtree) PARAM */
  BafNode jjtn000 = new BafNode(JJTPARAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) PARAM */
  try {
/*@egen*/
  ActionGeneric()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void ActionGeneric()     : {/*@bgen(jjtree) AC */
  BafNode jjtn000 = new BafNode(JJTAC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) AC */
  try {
/*@egen*/
  Name() <LPAREN> ( ParameterList() )? <RPAREN>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void ParameterList()       : {}
{
  Parameter() ( <COMMA> Parameter() )*
}

void Parameter()        : {/*@bgen(jjtree) PARAM */
  BafNode jjtn000 = new BafNode(JJTPARAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) PARAM */
  try {
/*@egen*/
  StringParameter()
| TargetParameter()
| NumberParameter()
| LOOKAHEAD(2) CombinedSymbolParameter()
| LOOKAHEAD(2) TargetObjectParameter()
| SymbolParameter()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void ObjectParameter()        : {/*@bgen(jjtree) PARAM */
  BafNode jjtn000 = new BafNode(JJTPARAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) PARAM */
  try {
/*@egen*/
  StringParameter()
| TargetParameter()
| LOOKAHEAD(2) TargetObjectParameter()
| SymbolParameter()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void StringParameter()            : {/*@bgen(jjtree) PARAM_STR */
  BafNode jjtn000 = new BafNode(JJTPARAM_STR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) PARAM_STR */
  try {
/*@egen*/
  StringExpression() ( LOOKAHEAD(2) Rectangle() )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void NumberParameter()            : {/*@bgen(jjtree) PARAM_NUM */
  BafNode jjtn000 = new BafNode(JJTPARAM_NUM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) PARAM_NUM */
  try {
/*@egen*/
  SignedNumber() ( OrNumberExpression() )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void CombinedSymbolParameter()            : {/*@bgen(jjtree) PARAM_NUM */
  BafNode jjtn000 = new BafNode(JJTPARAM_NUM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) PARAM_NUM */
  try {
/*@egen*/
  Name() ( OrNumberExpression() )+/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void OrNumberExpression()          : {/*@bgen(jjtree) OR_EXPR */
  BafNode jjtn000 = new BafNode(JJTOR_EXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) OR_EXPR */
  try {
/*@egen*/
  <OR> NumberExpression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void SymbolParameter()            : {/*@bgen(jjtree) PARAM_SYM */
  BafNode jjtn000 = new BafNode(JJTPARAM_SYM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) PARAM_SYM */
  try {
/*@egen*/
  Name() ( Rectangle() )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void TargetParameter()            : {/*@bgen(jjtree) PARAM_TGT */
  BafNode jjtn000 = new BafNode(JJTPARAM_TGT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) PARAM_TGT */
  try {
/*@egen*/
  TargetExpression() ( Rectangle() )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void TargetObjectParameter()       : {}
{
  TargetObject() ( LOOKAHEAD(2) Rectangle() )?
}

void Name()       : {/*@bgen(jjtree) NAME */
  BafNode jjtn000 = new BafNode(JJTNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) NAME */
  try {
/*@egen*/
  <IDENTIFIER>
| <IDENTIFIER_ESCAPED>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void NumberExpression()          : {/*@bgen(jjtree) NUMERIC */
  BafNode jjtn000 = new BafNode(JJTNUMERIC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) NUMERIC */
  try {
/*@egen*/
  SignedNumber() | Name()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void StringExpression()         : {/*@bgen(jjtree) STRING */
  BafNode jjtn000 = new BafNode(JJTSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) STRING */
  try {
/*@egen*/
  <STRING_LITERAL>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void TargetExpression()         : {/*@bgen(jjtree) TARGET */
  BafNode jjtn000 = new BafNode(JJTTARGET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) TARGET */
  try {
/*@egen*/
  <LBRACKET> NumberExpression() ( <DOT> NumberExpression() )* <RBRACKET>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void TargetObject()         : {/*@bgen(jjtree) OBJECT */
  BafNode jjtn000 = new BafNode(JJTOBJECT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) OBJECT */
  try {
/*@egen*/
  Name() ( TargetObjectArgument() )+/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void TargetObjectArgument()       : {}
{
  <LPAREN> ( TargetObjectArgumentType() )? <RPAREN>
}

void TargetObjectArgumentType()       : {}
{
  StringExpression()
| TargetExpression()
| LOOKAHEAD(2) TargetObject()
| TargetSymbol()
}

void TargetSymbol()         : {/*@bgen(jjtree) SYMBOL */
  BafNode jjtn000 = new BafNode(JJTSYMBOL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) SYMBOL */
  try {
/*@egen*/
  Name()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void Rectangle()       : {/*@bgen(jjtree) RECT */
  BafNode jjtn000 = new BafNode(JJTRECT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) RECT */
  try {
/*@egen*/
  <LBRACKET> SignedNumber() <DOT> SignedNumber() <DOT> SignedNumber() <DOT> SignedNumber() <RBRACKET>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void UnsignedNumber()       : {/*@bgen(jjtree) UINT */
  BafNode jjtn000 = new BafNode(JJTUINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) UINT */
  try {
/*@egen*/
  <NUMBER_LITERAL>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void SignedNumber()       : {/*@bgen(jjtree) SINT */
  BafNode jjtn000 = new BafNode(JJTSINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) SINT */
  try {
/*@egen*/
  ( Sign() )? UnsignedNumber()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void Sign()       : {/*@bgen(jjtree) SIGN */
  BafNode jjtn000 = new BafNode(JJTSIGN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) SIGN */
  try {
/*@egen*/
  <MINUS> | <PLUS>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}

void Negate()      : {/*@bgen(jjtree) NEG */
  BafNode jjtn000 = new BafNode(JJTNEG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) NEG */
  try {
/*@egen*/
  <BANG>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtn000.jjtSetLastToken(getToken(0));
    }
  }
/*@egen*/
}